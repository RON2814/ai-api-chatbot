<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>AI Chatbot</title>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=DM+Mono:wght@400;500&display=swap"
            rel="stylesheet"
        />
        <link rel="stylesheet" href="/static/style.css" />
    </head>
    <body>
        <div class="shell">
            <header>
                <div class="brand">
                    <div class="badge">AI Chatbot</div>
                    <div>Project Console</div>
                </div>
                <div class="status">
                    <span class="dot"></span>Backend reachable
                </div>
            </header>

            <main>
                <section class="chat-col">
                    <div id="messages" class="messages"></div>

                    <form id="chat-form">
                        <textarea
                            id="message"
                            name="message"
                            placeholder="Ask anything..."
                            required
                        ></textarea>
                        <button type="submit" id="send">Send</button>
                        <div class="provider-row">
                            <span class="muted small">Provider:</span>
                            <select id="provider">
                                <option value="">auto</option>
                                <option value="gemini">gemini</option>
                                <option value="openai">openai</option>
                            </select>
                            <input id="model" placeholder="model (optional)" />
                        </div>
                        <div id="error" class="error"></div>
                    </form>
                </section>

                <aside class="side">
                    <div class="card">
                        <div class="card-title">Quick actions</div>
                        <div class="button-row">
                            <button type="button" id="qa-clear">
                                Clear chat
                            </button>
                            <button type="button" id="qa-copy">
                                Copy chat
                            </button>
                            <button type="button" id="qa-export">
                                Export .txt
                            </button>
                        </div>
                        <div class="muted mt-8">
                            Simple utilities for your current conversation.
                        </div>
                    </div>
                    <div class="card">
                        <div class="card-title">Session</div>
                        <div class="muted">
                            Provider:
                            <span class="mono" id="cur-provider">auto</span>
                        </div>
                        <div class="muted">
                            Model:
                            <span class="mono" id="cur-model">default</span>
                        </div>
                        <div class="muted mt-6" id="last-finish"></div>
                    </div>
                </aside>
            </main>
        </div>

        <script>
            const form = document.getElementById("chat-form");
            const input = document.getElementById("message");
            const sendBtn = document.getElementById("send");
            const logEl = document.getElementById("messages");
            const errorEl = document.getElementById("error");
            const providerSelect = document.getElementById("provider");
            const modelInput = document.getElementById("model");
            const curProvider = document.getElementById("cur-provider");
            const curModel = document.getElementById("cur-model");
            const lastFinish = document.getElementById("last-finish");
            const qaClear = document.getElementById("qa-clear");
            const qaCopy = document.getElementById("qa-copy");
            const qaExport = document.getElementById("qa-export");

            const API_URL = "/api/chat";
            const STREAM_URL = "/api/stream";

            const addBubble = (role, html = "") => {
                const el = document.createElement("div");
                el.className = `bubble ${role}`;
                el.innerHTML = html;
                logEl.appendChild(el);
                logEl.scrollTop = logEl.scrollHeight;
                return el;
            };

            // Minimal markdown renderer: bold, italic, inline code, fenced code, line breaks.
            const renderMarkdown = (text) => {
                const escape = (s) =>
                    s
                        .replace(/&/g, "&amp;")
                        .replace(/</g, "&lt;")
                        .replace(/>/g, "&gt;");
                let html = escape(text);
                // fenced code blocks ``` ```
                html = html.replace(/```([\s\S]*?)```/g, (m, p1) => {
                    return `<pre><code>${p1}</code></pre>`;
                });
                html = html.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>");
                html = html.replace(/\*(.*?)\*/g, "<em>$1</em>");
                html = html.replace(/`([^`]+)`/g, "<code>$1</code>");
                html = html.replace(/\n/g, "<br>");
                return html;
            };

            // Reveal one line at a time for quicker perceived speed.
            const typeOutLines = (el, text, lineDelay = 60) =>
                new Promise((resolve) => {
                    const lines = text.split(/\n/);
                    let idx = 0;
                    const showNext = () => {
                        if (idx >= lines.length) return resolve();
                        const slice = lines.slice(0, idx + 1).join("\n");
                        el.innerHTML = renderMarkdown(slice);
                        logEl.scrollTop = logEl.scrollHeight;
                        idx += 1;
                        setTimeout(showNext, lineDelay);
                    };
                    showNext();
                });

            const setLoading = (loading) => {
                sendBtn.disabled = loading;
                sendBtn.textContent = loading ? "Sending…" : "Send";
            };

            const showError = (msg) => {
                errorEl.textContent = msg;
                errorEl.style.display = msg ? "block" : "none";
            };

            // Sidebar helpers
            const updateSessionInfo = (fromResponse) => {
                curProvider.textContent = providerSelect?.value || "auto";
                curModel.textContent =
                    modelInput?.value || fromResponse?.model || "default";
                if (fromResponse?.finish_reason) {
                    lastFinish.textContent =
                        "finish_reason: " + fromResponse.finish_reason;
                }
            };

            const bubblesToText = () => {
                const items = Array.from(logEl.querySelectorAll(".bubble"));
                return items
                    .map((el) => {
                        const role = el.classList.contains("user")
                            ? "User"
                            : "Assistant";
                        return `${role}: ${el.innerText}`;
                    })
                    .join("\n\n");
            };

            qaClear?.addEventListener("click", () => {
                logEl.innerHTML = "";
                lastFinish.textContent = "";
            });

            qaCopy?.addEventListener("click", async () => {
                try {
                    await navigator.clipboard.writeText(bubblesToText());
                } catch (e) {
                    console.error("Copy failed", e);
                }
            });

            qaExport?.addEventListener("click", () => {
                try {
                    const txt = bubblesToText();
                    const blob = new Blob([txt], { type: "text/plain" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    const ts = new Date().toISOString().replace(/[:.]/g, "-");
                    a.href = url;
                    a.download = `chat-${ts}.txt`;
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    URL.revokeObjectURL(url);
                } catch (e) {
                    console.error("Export failed", e);
                }
            });

            providerSelect?.addEventListener("change", () =>
                updateSessionInfo()
            );
            modelInput?.addEventListener("change", () => updateSessionInfo());
            updateSessionInfo();

            let lastUserText = "";

            form.addEventListener("submit", async (e) => {
                e.preventDefault();
                const text = input.value.trim();
                if (!text) return;

                showError("");
                addBubble("user", text);
                setLoading(true);
                input.value = "";
                lastUserText = text;

                try {
                    const res = await fetch(STREAM_URL, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            message: text,
                            provider: providerSelect?.value || undefined,
                            model: modelInput?.value || undefined,
                        }),
                    });
                    if (!res.ok || !res.body) {
                        throw new Error(`HTTP ${res.status}`);
                    }
                    const botBubble = addBubble("bot", "");
                    const reader = res.body.getReader();
                    const decoder = new TextDecoder("utf-8");
                    let buffer = "";
                    let lastFinish = null;
                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;
                        buffer += decoder.decode(value, { stream: true });
                        const parts = buffer.split("\n\n");
                        buffer = parts.pop();
                        for (const ev of parts) {
                            const line = ev
                                .split("\n")
                                .find((l) => l.startsWith("data:"));
                            if (!line) continue;
                            const json = line.slice(5).trim();
                            if (!json) continue;
                            let obj = {};
                            try {
                                obj = JSON.parse(json);
                            } catch {}
                            if (obj.delta) {
                                const current = botBubble.innerText || "";
                                const next = current + obj.delta;
                                botBubble.innerHTML = renderMarkdown(next);
                                logEl.scrollTop = logEl.scrollHeight;
                            }
                            if (obj.error) {
                                showError(obj.detail || obj.error);
                            }
                            if (obj.done) {
                                lastFinish = obj.finish_reason || null;
                                updateSessionInfo({
                                    model: obj.model,
                                    finish_reason: obj.finish_reason,
                                });
                            }
                        }
                    }
                    if (
                        lastFinish &&
                        ["MAX_TOKENS", "length"].includes(String(lastFinish))
                    ) {
                        const warn = document.createElement("div");
                        warn.className = "muted";
                        warn.style.fontSize = "12px";
                        warn.style.marginTop = "6px";
                        warn.textContent =
                            "Response may be cut short (finish_reason=" +
                            lastFinish +
                            ").";
                        botBubble.appendChild(warn);
                    }
                    // Add a refresh icon beside this bot response to regenerate
                    const actions = document.createElement("div");
                    actions.className = "bubble-actions";
                    const refresh = document.createElement("button");
                    refresh.type = "button";
                    refresh.className = "icon-btn";
                    refresh.title = "Regenerate this answer";
                    refresh.textContent = "↻";
                    refresh.addEventListener("click", () => {
                        input.value = text; // re-use the same prompt
                        form.requestSubmit();
                    });
                    actions.appendChild(refresh);
                    botBubble.appendChild(actions);
                } catch (err) {
                    showError(err.message || "Something went wrong");
                    addBubble(
                        "bot",
                        "⚠️ There was an issue processing your request."
                    );
                    console.error("/api/stream failed", err);
                } finally {
                    setLoading(false);
                }
            });

            // Enter-to-send (Shift+Enter for newline)
            input.addEventListener("keydown", (e) => {
                if (e.key === "Enter" && !e.shiftKey) {
                    e.preventDefault();
                    form.requestSubmit();
                }
            });

            // Removed global Regenerate button; per-message refresh icon is added next to each AI response.

            // Seed a welcome message
            addBubble("bot", "Hi! I am your AI assistant. Ask me anything.");
        </script>
    </body>
</html>
